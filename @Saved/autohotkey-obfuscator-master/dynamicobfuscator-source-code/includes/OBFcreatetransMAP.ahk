/*
	DYNAMIC OBFUSCATOR is an obfuscator for autohotkey scripts that
	can obfuscate functions, autohotkey functions, labels,
	parameters, and variables. It can automatically use the dynamic
	variable creation features of autohotkey to create breakable
	code sections and function path rewiring.

	Copyright (C) 2011-2013  David Malia

	This program is free software: you can redistribute it and/or 
	modify it under the terms of the GNU General Public License as
	published by the Free Software Foundation, either version 3 of
	the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see
	<http://www.gnu.org/licenses/>.

	David Malia, 11 Cedar Ct, Augusta ME, USA
	dave@dynamicobfuscator.org
	http://davidmalia.com
	
*/



createTRANSMAP()
{
	global
	
	createTRANSMAPmesswin()
	
	FileRead, fileslist, % myfileslistfile
		
	FormatTime, currenttime
	
	writetoMAPfilestr=
	
	MAPfilestr =
(

	OBFUSCATOR FIND FUNCTION AND LABEL HEADERS MAP OUTPUT FILE
	Date: %currenttime%

	This is an automatically generated 'map' of the functions and label sections
	found in the ahk source files specified by the user.
	This file can be used as the beginning point in the next step of obfuscation
	of the source files - the actual obfuscation!
	
	For each fuction definition or label section that is found in the source code
	files, the corresponding one of the 2 obfuscator commands below will be printed
	in this file, all the way to the left most column, with the '$' in column 1.
	Only the function name or label name parameter will be supplied by this 
	program, the other parameters will use the current 'defaults'. To use different
	values than the current defaults, just add them to the obfuscator command
	generated by this program for that label section or function definition.
	That will then change the 'defaults' for all subsequent commands that do not
	supply new values.
	
	$DEFFUNC: func name, new func name size min/max, divide into num frags,
		 number frag sets, frag var size min/max, add null frags
	$DEFLABEL: label name, new label name size min/max, divide into num frags,
	 number frag sets, frag var size min/max, add null frags
	 
	#FILE IN WHICH THE LIST OF SOURCE CODE FILES TO PROCESS WAS RETRIEVED:
	%myfileslistfile%
	 
	#LIST OF FILES FOUND IN THAT FILE:

%fileslist%

	#OUTPUT FILE NAME(this file):
	%myMAPfilename%
)
	writetoMAPfile(MAPfilestr)
	
	initOBFdefaults()
	init_changedefaultsCOMMs()
	
	MAPfilestr = 
(	
	    
	Change the values assigned to the program start defaults below to use
	different starting values when this map file is input to the obfuscator.

)
	writetoMAPfile(MAPfilestr)
	
	;write out all default values
	loop, % numvartypes
	{
		curdeftype = % vartype%a_index%
		loop, % numdefaultprop
		{
			curdefprop = % defaultprop%a_index%
			fullpropname = %curdeftype%_%curdefprop%
			writetoMAPfile("#StartDefault: " . fullpropname . ", " . %fullpropname%)
		}
		writetoMAPfile("")
	}
		
	totalsourcelines = 0
	
	;after label sections and function are 'broken off'
	;this is the function name that will be called to process it
	;this can have 2 different values
	processcodesection = % "MAPcodesection"
	
	; Specifying `n prior to `r allows both Windows and Unix files to be parsed.
	Loop, parse, fileslist, `n, `r
	{
		curfilenum = %  A_Index
		;file name and the number it is in the list
		parse_onefile(A_LoopField, A_Index)				
	}
	

	msgbox, % "writetoMAPfilestr, length: " . strlen(writetoMAPfilestr) 
	
	closeMAPfile()
			
	showmyprocmess("Total source code lines processed: " . totalsourcelines)
	
	return
}

MAPcodesection(preLOFlines, ByRef LOFheaderline, ByRef LOFbodylines, LOFtype, LOFname)
{
	;LOCAL
	

	if (LOFtype = "label") 			
		mysecttype = % "label:global"
	else if (LOFtype = "hotkey") 
		mysecttype = % "label:hotkey"
	else if (LOFtype = "function") 
		mysecttype = % "function"
	else if (LOFtype = "autoexecute") {
		mysecttype = % "label:autoexecute"	
	}

	;the routine below will slow down the program enormously!
	;showmyprocmess("MAPPING CODE SECTION: " . mysecttype, LOFheaderline)

	writeLOFtoTRANSMAP(preLOFlines, LOFheaderline, LOFtype,  LOFname)
	
	;look for nested label tags
	Loop, parse, LOFbodylines, `n, `r
	{
		LOFname = 
		preLOFlines =
		if IS_OBFCOMM(A_Loopfield) {
			passthruCOMM(LOFtype)
			continue
		}
		LOFtype2 =
		if (isLOFheader(A_Loopfield, LOFtype2, LOFname, 1) and LOFtype2 = "label") {
			showmyprocmess("  *NESTED LABEL FOUND: " . LOFname)
			writeLOFtoTRANSMAP(preLOFlines, A_Loopfield, LOFtype2, LOFname, "NESTED")
		}
	}

}

;check for all obfuscater commands that might be in the source code
;that i need to 'pass through' and put in the translations map
passthruCOMM(cursectiontype = "")
{
	global	
	
	if ischangedefaultsCOMM(CUR_OBFCOMM) {
		;'pass through' this command and put it in the translations map
		writetoMAPfile("`r`n$" . CUR_OBFCOMM . ": " . CUR_COMMPARAMS)
		return	
	}
	
	if (CUR_OBFCOMM = create_objsCLASS or CUR_OBFCOMM = add_followingtoCLASS) {
		;'pass through' this command and put it in the translations map
		writetoMAPfile("`r`n$" . CUR_OBFCOMM . ": " . CUR_COMMPARAMS)
		return	
	}
	
	if (CUR_OBFCOMM	= restoreallCOM) {
		;'pass through' this command and put it in the translations map
		writetoMAPfile("`r`n$" . CUR_OBFCOMM . ": " . CUR_COMMPARAMS)
		return	
	}
	
	;DEFINE GLOBALS OR SYSTEM FUNCTIONS
	if (CUR_OBFCOMM	= def_SYSFUNCS or CUR_OBFCOMM = def_GLOBVARS) {
		;'pass through' this command and put it in the translations map
		writetoMAPfile("`r`n$" . CUR_OBFCOMM . ": " . CUR_COMMPARAMS)
		return	
	}
	
	;DEFINES THE ORDER IN WHICH TO DUMP FUNCTION AND LABEL SOURCE CODE
	if (CUR_OBFCOMM	= "DUMP_FUNCandLABEL_CODE") {
		;'pass through' this command and put it in the translations map
		writetoMAPfile("`r`n$" . CUR_OBFCOMM . ": " . CUR_COMMPARAMS)
		return	
	}
	
	;alows me to 'rewire' calls to functions so that a call to a function
	;will go to a different function!!
	if (CUR_OBFCOMM	= "DUMP_REWIREFUNCPATH") {
		;'pass through' this command and put it in the translations map
		writetoMAPfile("`r`n$" . CUR_OBFCOMM . ": " . CUR_COMMPARAMS)
		return	
	}
	
	;SPECIAL CASE when the gui, +Label????? is used with a gui
	if (CUR_OBFCOMM	= "DEFGUICLOSELAB") {
		;'pass through' this command and put it in the translations map
		writetoMAPfile("`r`n$" . CUR_OBFCOMM . ": " . CUR_COMMPARAMS)
		return	
	}
	
	if (CUR_OBFCOMM = def_PARAMS) {
		;'pass through' this command and put it in the translations map
		writetoMAPfile("`r`n$" . CUR_OBFCOMM . ": " . CUR_COMMPARAMS)
		return
	}
			
	;these 2 commands are only allowed inside a function
	;DEFINE LOCAL OR STATIC OR DEFINE FUNCandVAR
	if (CUR_OBFCOMM	= def_LOSVARS or CUR_OBFCOMM = def_FUNCandVARS) 
	{
		if (cursectiontype = "function") {
			;'pass through' this command and put it in the translations map
			writetoMAPfile("`r`n$" . CUR_OBFCOMM . ": " . CUR_COMMPARAMS)
			return
		} else {
			;these 2 commands are only allowed inside a function and they
			;were found outside
			writetoMAPfile("`r`n#ERROR: COMMAND FOUND OUTSIDE FUNC BODY THAT IS NOT ALLOWED THERE")
			writetoMAPfile("#COMMAND FOUND: " . CUR_OBFCOMM . ": " . CUR_COMMPARAMS)
			return
		}
	}
}

getcommparams()
{
	global
	local passparams
	
	return, % CUR_COMMPARAMS
	
	passparams =
	loop, % numOBFcomms
	{
		 if (a_index <> 1)
			OBFcommstr .= " / "
		 passparams .= obfparam%a_index%				
	}
	return, % passparams
}


writeLOFtoTRANSMAP(preLOFlines, LOFheaderline, LOFtype, LOFname, specialcase = "")
{
		
	writetoMAPfile("")
	if preLOFlines is not space
		writetoMAPfile(preLOFlines)
			
	if (LOFtype = "autoexecute") {
		writetoMAPfile("#FOUND: *AUTOEXECUTE SECTION FOUND*") 
		return		
	}
	
	if (LOFtype = "hotkey") {
		writetoMAPfile("#FOUND: *HOTKEY: " . LOFname . "`r`n") 
		return		
	}
	
	if (LOFtype = "function")
		OBFfunc = % "$DEFFUNCS: "	
	else if (LOFtype = "label")
		OBFfunc = % "$DEFLABELS: "
	else {
		writetoMAPfile("`r`n;*LOFtype ERROR* LOFtype: " . LOFtype . " funcorlabelname: " . LOFname . "`r`n")
		return
	}
	
	if (specialcase = "NESTED")
		writetoMAPfile("#NESTED LABEL FOUND#")
	
	writetoMAPfile("#FOUND: " . LOFheaderline)
	writetoMAPfile(OBFfunc . LOFname)
	
	;if it is a function, parse out any parameters found and 
	;write 'map' tags for those as well
	if (LOFtype = "function") {
		paramslist = % substr(LOFheaderline, (strlen(LOFname) + 2))
		closingpar = % instr(paramslist, ")")
		if (!closingpar) {
			writetoMAPfile("# *PARAMETERS ERROR*")
			return		
		}
		paramslist = % substr(paramslist, 1, (closingpar - 1))
				
		Loop, Parse, paramslist, `,, %A_Space%%A_Tab%
		{
			myparam = % A_Loopfield
			
			first6chars = % substr(myparam, 1, 6)
			StringUpper, first6chars, first6chars
			if (first6chars = "BYREF ")
				myparam = % substr(myparam, 7)
			
			if (foundequal := instr(myparam, "=")) {
				myparam = % substr(myparam, 1, (foundequal - 1))
				;removes any excess spaces
				myparam = %myparam%
			}			
				
			writetoMAPfile("$DEFPARAMS: " . myparam)
		}	
	}	
}

createTRANSMAPmesswin()
{
	global
	
	gui 10:default
	
	gui, margin, 40, 20
	
	gui, font, %scl_basefont%  norm
	gui, add, text, xm ym vgetspacewidth, % " "
	GuiControlGet, spacewidth, Pos, getspacewidth
	
	gui, font, %scl_h1font% bold
	gui, add, text, xp yp, Mapping Functions and Label Sections in Source Code 
	
	editwidth = % "W" . (spacewidthW * 140)
	
	gui, font, %scl_basefont%  norm
	
	gui, add, text, xm y+30, Source code file name being processed
	gui, add, edit, xm y+4 readonly Vshowscodefilename %editwidth% C009900
	
	;gui, add, text, xm y+30, Processing messages
	;gui, add, edit, xm y+4 R6 readonly Vshowprocessmess %editwidth% C009900
	
	gui, add, text, xm y+20
	
	gui, add, button, xm+30 yp GchooseOBFfunc, Choose OBF fuction
	
	gui, show,, Mapping Source Code Files
}

showmyprocmess(message, funcorlabelname = "")
{	
	global curfilenum
	
	static allmesslines := ""
	
	IF (funcorlabelname)
		showfuncname = % "  name: " . funcorlabelname
	else
		showfuncname = % ""
		
	allmesslines .= "file#" . curfilenum . "  " . message . showfuncname  . "`r`n" 
	
	;write file name to window that shows 'running' info
	;THE STATEMENT BELOW WILL SLOW DOWN THE PROGRAM BIG TIME!
	;GuiControl,, showprocessmess, % allmesslines	
}



writetoMAPfile(writethis)
{
	global
	
	if (!writetoMAPfilestr)
		 VarSetCapacity(writetoMAPfilestr, 120000)
		 
	writetoMAPfilestr .= writethis . "`r`n"
}
closeMAPfile()
{
	global	
	
	;delete if already exists
		
	FileDelete, % myMAPfilename	
	FileAppend, % writetoMAPfilestr, % myMAPfilename	
}

